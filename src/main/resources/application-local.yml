server:
  port: 8081

#jpa:
#  properties:
#    hibernate:
#      hbm2ddl:
#        auto: update
#        dialect: org.hibernate.dialect.MySQL5InnoDBDialect
#        show_sql: true
#        format_sql: true
#
#        jpa:
#          properties:
#            hibernate:
#              hbm2ddl:
#                auto: update
#                dialect: org.hibernate.dialect.MySQL5InnoDBDialect
#                show_sql: true
#                format_sql: true



#  jpa:
#    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
#    open-in-view: true
#    show-sql: true
#    hibernate:
#      ddl-auto: update
#      naming:
#        # PhysicalNamingStrategyStandardImpl : 내가 지정한 필드명 그대로 사용한다.
#        # SpringPhysicalNamingStrategy : 자동으로 내가 지정한 필드를 CamelToe에서 언더바 명명으로 바꿔준다 (emailName->email_name)
#        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
#      # JPA의 기본 넘버링 strategy를 따라가지 않고 연결된 DB의 넘버링을 선택한다 (False)
#      use-new-id-generator-mappings: false
#      # console 창에 보여준다 true
#      show-sql: true
#      properties:
#        # console 창에 query보여줄 때 이쁘게 보여준 true
#        hibernate.format_sql: true

#jpa:
#  dialect: org.hibernate.dialect.MySQL5InnoDBDialect
#  open-in-view: true
#  hibernate:
#    ddl-auto: update
#    naming:
#      # PhysicalNamingStrategyStandardImpl : 내가 지정한 필드명 그대로 사용한다.
#      # SpringPhysicalNamingStrategy : 자동으로 내가 지정한 필드를 CamelToe에서 언더바 명명으로 바꿔준다 (emailName->email_name)
#      physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
#    # JPA의 기본 넘버링 strategy를 따라가지 않고 연결된 DB의 넘버링을 선택한다 (False)
#    use-new-id-generator-mappings: false
#  # console 창에 보여준다 true
#  show-sql: true
#  properties:
#    # console 창에 query보여줄 때 이쁘게 보여준 true
#    hibernate.format_sql: true







springdoc:
 swagger-ui:
    path: /framework/demo
    operationsSorter: method
    mainDescription: |
      **<  SWAGGER-UI 사용자 메뉴얼 >**  
      
      **STEP 1 --------------------------------------------------------------------------------------------**  
      
      [USER] Account 클래스의 **로그인 API**를 통해 로그인 후 Access/Refresh Token 을 발급받는다.  
      
      **STEP 2 --------------------------------------------------------------------------------------------**           
      
      우측 하단의 **Authorize**에 Access Token 을 등록한다 (전역 헤더 설정).   
      
      **STEP 3 --------------------------------------------------------------------------------------------**    
      
      Access Token 의 전역 헤더 설정을 완료 했다면 API에 접근 할 수 있다.  
      
      **STEP 4 --------------------------------------------------------------------------------------------**   
      
      API 사용시 **403 Forbidden**이 발생한다면 Access Token 이 말료된 것으로  
      [AUTH] 인증/인가 클래스의 Token Refresh API를 통해 Access Token 을 재발급 받는다.  
      토큰 재발급 후 STEP 2,3 과정을 수행한다.
      
    
      

logging:
     level:
       com:
         security:
           test: DEBUG
           org:
             springframework:
               web: DEBUG
               jdbc: DEBUG
               hibernate:
                 type:
                   descriptor:
                     sql:
                       BasicBinder: TRACE
                       SQL: DEBUG


